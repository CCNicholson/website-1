---
title: 'Day 3 - Data import, functions and factors'
author: ''
date: '2017-08-29'
slug: day-3-import
categories: []
tags: []
draft: TRUE
---



<div id="preparation-and-introduction" class="section level1">
<h1>Preparation and Introduction</h1>
<div id="student-learning-objectives" class="section level3">
<h3>Student Learning Objectives</h3>
<p>After completing this lab you should be able to</p>
<ul>
<li>Import data that is stored in an external Excel, CSV or tab-delimited text file into R.</li>
<li>Specify arguments to functions in R positionally and by name.</li>
<li>Create and control the labeling and ordering of categorical variables (factors).</li>
</ul>
</div>
<div id="preparation-whats-a-delimiter" class="section level3">
<h3>Preparation: What’s a delimiter?</h3>
<p>Before we go much further, let’s talk about the word <strong><em>delimiter</em></strong>. This is the character, or symbol, that separates columns of data from each other when stored in an external file. This file could be a simple <code>.txt</code> text file or an <code>.xlsx</code> Excel file. Recall back to the Data Camp exercises on data frames and matrices. Each column in the matrix represented data on a specific variable. Something had to tell R how to distinguish which values went with which variable.</p>
<p>There are two main types of delimiters we will consider in this class; comma and tab. That does not mean that data can’t be stored in other ways, these are just the two most common.</p>
</div>
<div id="preparation-data-to-download" class="section level3">
<h3>Preparation: Data to download</h3>
<ul>
<li>Go to the cleaned data section of the <a href="../../data/">datasets page</a> and download the following data sets: <code>NCBirths</code>, <code>email</code>, and <code>parHIV</code>.</li>
<li><strong>DO NOT RENAME ANYTHING</strong> If you download multiple copies of the data, do not keep the versions that have a (1) or some number in the name.</li>
<li>Put all downloaded data files into your MATH130 folder.</li>
</ul>
<p>In all the examples below, the path shown (<code>../data/</code>) is the path on <strong>MY</strong> computer.You will have to update this path to <strong>YOUR</strong> path on <strong>YOUR</strong> machine that points to your MATH130 folder.</p>
</div>
</div>
<div id="importing-data" class="section level1">
<h1>Importing Data</h1>
<p>In this workshop we are only going to explore reading flat files that exist on your computer into R from three most commonly used data sources: A tab-delimited text file, A CSV file and an Excel file. Ideally each row represents data on a single observation and each column contains data on a single variable, or characteristic, of the observation. This is called <code>tidy data</code>. We will start to learn some tools to look at the data, and for getting data from an external file into R for analysis.</p>
<div id="text-files" class="section level3">
<h3>Text files</h3>
<p>Text files are very simple files that have a <code>.txt</code> file extension. Common delimiters include a space, a comma (,) or a tab. Uncommon delimiters could include a % or even a semi-colon. Follow along with these examples and make sure you can read in the data correctly and that it matches what is shown below.</p>
<p>We will use the <code>read.table()</code> function that is in base R to read in any type of delimited file. A tab-delimited text file can be read in using <code>&quot;\t&quot;</code> as the deliminator character. In this class you <strong>ALWAYS</strong> want to include <code>header=TRUE</code> to signify that the data in the first row contains our column names.</p>
<pre class="r"><code>email &lt;- read.table(&quot;../data/email.txt&quot;, header=TRUE, sep=&quot;\t&quot;)
str(email)</code></pre>
<pre><code>## &#39;data.frame&#39;:    3921 obs. of  21 variables:
##  $ spam        : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ to_multiple : int  0 0 0 0 0 0 1 1 0 0 ...
##  $ from        : int  1 1 1 1 1 1 1 1 1 1 ...
##  $ cc          : int  0 0 0 0 0 0 0 1 0 0 ...
##  $ sent_email  : int  0 0 0 0 0 0 1 1 0 0 ...
##  $ time        : Factor w/ 3840 levels &quot;2011-12-31 22:16:41&quot;,..: 1 2 6 3 4 5 7 10 14 8 ...
##  $ image       : int  0 0 0 0 0 0 0 1 0 0 ...
##  $ attach      : int  0 0 0 0 0 0 0 1 0 0 ...
##  $ dollar      : int  0 0 4 0 0 0 0 0 0 0 ...
##  $ winner      : Factor w/ 2 levels &quot;no&quot;,&quot;yes&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ inherit     : int  0 0 1 0 0 0 0 0 0 0 ...
##  $ viagra      : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ password    : int  0 0 0 0 2 2 0 0 0 0 ...
##  $ num_char    : num  11.37 10.5 7.77 13.26 1.23 ...
##  $ line_breaks : int  202 202 192 255 29 25 193 237 69 68 ...
##  $ format      : int  1 1 1 1 0 0 1 1 0 1 ...
##  $ re_subj     : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ exclaim_subj: int  0 0 0 0 0 0 0 0 0 0 ...
##  $ urgent_subj : int  0 0 0 0 0 0 0 0 0 0 ...
##  $ exclaim_mess: int  0 1 6 48 1 1 1 18 1 0 ...
##  $ number      : Factor w/ 3 levels &quot;big&quot;,&quot;none&quot;,&quot;small&quot;: 1 3 3 3 2 2 1 3 3 3 ...</code></pre>
</div>
<div id="csv-comma-separated-values" class="section level3">
<h3>CSV: Comma Separated Values</h3>
<p>CSV is a fancy way of saying a text file with comma-separated values (i.e. CSV). We could use <code>read.table()</code> but <code>read.csv()</code> is optimized to read in CSV files.</p>
<pre class="r"><code>NCbirths &lt;- read.csv(&quot;../data/NCbirths.csv&quot;, header=TRUE)
str(NCbirths)</code></pre>
<pre><code>## &#39;data.frame&#39;:    1000 obs. of  13 variables:
##  $ fage          : int  NA NA 19 21 NA NA 18 17 NA 20 ...
##  $ mage          : int  13 14 15 15 15 15 15 15 16 16 ...
##  $ mature        : Factor w/ 2 levels &quot;mature mom&quot;,&quot;younger mom&quot;: 2 2 2 2 2 2 2 2 2 2 ...
##  $ weeks         : int  39 42 37 41 39 38 37 35 38 37 ...
##  $ premie        : Factor w/ 2 levels &quot;full term&quot;,&quot;premie&quot;: 1 1 1 1 1 1 1 2 1 1 ...
##  $ visits        : int  10 15 11 6 9 19 12 5 9 13 ...
##  $ marital       : Factor w/ 2 levels &quot;married&quot;,&quot;not married&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ gained        : int  38 20 38 34 27 22 76 15 NA 52 ...
##  $ weight        : num  7.63 7.88 6.63 8 6.38 5.38 8.44 4.69 8.81 6.94 ...
##  $ lowbirthweight: Factor w/ 2 levels &quot;low&quot;,&quot;not low&quot;: 2 2 2 2 2 1 2 1 2 2 ...
##  $ gender        : Factor w/ 2 levels &quot;female&quot;,&quot;male&quot;: 2 2 1 2 1 2 2 2 2 1 ...
##  $ habit         : Factor w/ 2 levels &quot;nonsmoker&quot;,&quot;smoker&quot;: 1 1 1 1 1 1 1 1 1 1 ...
##  $ whitemom      : Factor w/ 2 levels &quot;not white&quot;,&quot;white&quot;: 1 1 2 2 1 1 1 1 2 2 ...</code></pre>
</div>
<div id="excel-files" class="section level3">
<h3>Excel files</h3>
<p>The best method I have found so far to read in Excel files is from the <a href="http://readxl.tidyverse.org/"><code>readxl</code> package</a> by <a href="http://hadley.nz/">Hadley Wickham</a>. This package need to be installed first, and then can be simply loaded each time you start an <code>R</code> session where you will be reading in this type of data. Go ahead and install it now.</p>
<p>The <code>read_excel()</code> function is what we are going to use. Note the use of the underscore <code>_</code> instead of a period <code>.</code> between read and the file type.</p>
<pre class="r"><code>library(readxl)
parHIV  &lt;- read_excel(&quot;../data/PARHIV_090516.xlsx&quot;, sheet=1, col_names=TRUE)
# str(parHIV) #Not run due to the length of output.
parHIV[1:10,1:10]</code></pre>
<pre><code>## # A tibble: 10 x 10
##       ID   AGE GENDER LIVWITH SIBLINGS JOBMO EDUMO HOWREL ATTSERV NGHB1
##    &lt;dbl&gt; &lt;dbl&gt;  &lt;chr&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;  &lt;dbl&gt;   &lt;dbl&gt; &lt;dbl&gt;
##  1     1    17   Male       3        2    NA     2     NA      NA     2
##  2     2    18 Female       1       NA     1     2      2       2     4
##  3     3    13   Male       2        2     2     1     NA      NA     1
##  4     4    14 Female       2        2     2     3      3       1     3
##  5     5    14   Male       2        2     2     3      2       1     3
##  6     6    13   Male       2        2     2    NA      2       2     2
##  7     7    14 Female       2        2     2     2      2       2     2
##  8     8    14 Female       2        2     2     2      1       3     3
##  9     9    13 Female       2        2     2     3     NA      NA     4
## 10    10    13   Male       1        2    NA    NA     NA      NA     1</code></pre>
<p>Due to the large number of variables (123) in this parental HIV data set, <code>str</code> is not used to demonstrate what the data looks like, instead the first 10 rows and first 10 columns are displayed.</p>
<div id="interlude-what-are-those-nas" class="section level4">
<h4><strong>INTERLUDE:</strong> What are those <code>NA</code>’s?</h4>
<p>R puts a <code>NA</code> as a placeholder when the value for that piece of data is missing. This is important because <code>R</code> can’t do arithmetic on missing data. So <code>5 + NA = NA</code>. This can cause confusion when trying to calculate summary statistics and plot data.</p>
<p>Resources for learning about how R handles missing data</p>
<ul>
<li><a href="http://www.statmethods.net/input/missingdata.html" class="uri">http://www.statmethods.net/input/missingdata.html</a></li>
<li><a href="http://www.ats.ucla.edu/stat/r/faq/missing.htm" class="uri">http://www.ats.ucla.edu/stat/r/faq/missing.htm</a></li>
<li><a href="http://faculty.nps.edu/sebuttre/home/R/missings.html" class="uri">http://faculty.nps.edu/sebuttre/home/R/missings.html</a></li>
</ul>
<p>One of the best statistical methods for dealing with Missing data is called Multiple Imputation. Here is a link to learn more about this method. <a href="https://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/" class="uri">https://www.r-bloggers.com/imputing-missing-data-with-r-mice-package/</a> <strong>Caution: Do not use without consultation of a trained Statistician.</strong></p>
</div>
</div>
</div>
<div id="factors" class="section level1">
<h1>Factors</h1>
<p>The term factor refers to a statistical data type used to store categorical variables. The difference between a categorical variable and a continuous variable is that a categorical variable corresponds to a limited number of categories, while a continuous variable can correspond to an infinite number of values.</p>
<p>An example of a categorical variable is the <code>number</code> variable in the <code>email</code> data set. This variable contains data on whether there was no number, a small number (under 1 million), or a big number in the content of the email.</p>
<pre class="r"><code>table(email$number)</code></pre>
<pre><code>## 
##   big  none small 
##   545   549  2827</code></pre>
<pre class="r"><code>class(email$number)</code></pre>
<pre><code>## [1] &quot;factor&quot;</code></pre>
<p>We can see that <code>R</code> recognizes this variable as a factor variable, and that it has the three levels: <code>big</code>, <code>none</code>, and <code>small</code>.</p>
<pre class="r"><code>levels(email$number)</code></pre>
<pre><code>## [1] &quot;big&quot;   &quot;none&quot;  &quot;small&quot;</code></pre>
<div id="ordering-of-factors" class="section level4">
<h4>Ordering of Factors</h4>
<p>Take a moment to examine the previous table. Specifically the ordering from left to right of the factors. Seem odd? This is ordinal data, in that <code>none</code> is inherently “smaller” than <code>small</code>, which is smaller than <code>big</code>. But the ordering goes <code>big</code> - <code>none</code> - <code>small</code>, which is in Alphabetical order!</p>
<p>Gee thanks R. Exactly how I want my factors ordered (NOT!)</p>
<p>We need to take control of these factors! We can do that by specifying the <code>levels</code> of the factor. Let’s create a new factor variable called <code>numsize</code> that contains the data from <code>number</code>, but in the factor ordering that we want.</p>
<pre class="r"><code>email$numsize &lt;- factor(email$number, levels = c(&quot;none&quot;, &quot;small&quot;, &quot;big&quot;))
table(email$numsize)</code></pre>
<pre><code>## 
##  none small   big 
##   549  2827   545</code></pre>
<p>There we go. Now it’s in a readable, left to right in increasing size order.</p>
</div>
<div id="naming-of-factors" class="section level4">
<h4>Naming of Factors</h4>
<p>Let’s consider another factor variable on the email data set, <code>spam</code>.</p>
<pre class="r"><code>table(email$spam)</code></pre>
<pre><code>## 
##    0    1 
## 3554  367</code></pre>
<pre class="r"><code>class(email$spam)</code></pre>
<pre><code>## [1] &quot;integer&quot;</code></pre>
<p>Note it is simply displayed as a 0 or 1, and <code>R</code> is treating this variable as a numeric integer variable. Well, by reading the codebook we know that in the data this variable is a <em>binary indicator</em> variable to identify whether or not the email is flagged as spam or not. The data has been <em>coded</em> such that 0 = “Not Spam” and 1 = “Spam”. So let’s change the <em>labels</em> of the <code>spam</code> variable to reflect this knowledge.</p>
<pre class="r"><code>email$spam_labeled &lt;- factor(email$spam, labels =c(&quot;Not Spam&quot;, &quot;Spam&quot;))
table(email$spam, email$spam_labeled)</code></pre>
<pre><code>##    
##     Not Spam Spam
##   0     3554    0
##   1        0  367</code></pre>
<p>It is good habit to not overwrite the same variable, but to create a new one entirely when you are relabeling or reordering factor variables. That way you can confirm that the values you changed were changed correctly. We will discuss this <code>table()</code> function a little later.</p>
</div>
</div>
<div id="functions-and-their-arguments" class="section level1">
<h1>Functions and their arguments</h1>
<p>By now you’ve seen the term <code>function</code> being thrown around all over the place. Functions take inputs, called <strong>arguments</strong> and provide outputs, or results. A few functions you have already used are <code>head()</code>, <code>table()</code> and <code>subset()</code>. Let’s look at the <code>mean</code> function again by typing ?mean.</p>
<p>The <strong>Usage</strong> section of the documentation includes two versions of the mean() function; What’s the difference? The first function</p>
<pre class="r"><code>mean(x,...)</code></pre>
<p>is the most general definition of the mean function. This section also shows you what the default values for each argument are. This is a very important piece to pay attention. Sometimes the default behaviors are not what you want to happen.</p>
<pre class="r"><code>mean(x, trim = 0, na.rm = FALSE, ...)</code></pre>
<p>In the <strong>Arguments</strong> section the help file defines what each argument does.</p>
<ul>
<li><code>x</code> is the object that you want to take the mean of</li>
<li><code>trim</code> is a number from 0 to 0.5 that defines the fraction of observations to be excluded from each side before the mean is calculated.</li>
<li><code>na.rm</code> is a logical value (<code>TRUE</code>/<code>FALSE</code>) that tells <code>R</code> whether NA values should be stripped before the computation proceeds.</li>
<li><code>...</code> is called the ellipsis, and it is a way for R to pass arguments to or from other methods without the function having to name them explicitly.</li>
</ul>
<div id="argument-ordering" class="section level2">
<h2>Argument ordering</h2>
<p>A function’s arguments can be named, or can be referred to by position. As an example, let’s look at a vector of random numbers where some of the data is missing.</p>
<pre class="r"><code>y &lt;- sample(1:100, 20)
y[sample(1:length(y),5)] &lt;- NA
y</code></pre>
<pre><code>##  [1] 49  3 98 47 NA 77 NA NA NA 37 NA 88 14 92 27 44 76 54 71 68</code></pre>
<p>Now, let’s calculate the mean.</p>
<pre class="r"><code>mean(y)</code></pre>
<pre><code>## [1] NA</code></pre>
<p>Oops, forgot about the missing values. We need to tell R to <em>remove</em> the <code>NA</code>’s from the data prior to calculating the mean.</p>
<pre class="r"><code>mean(y, na.rm=TRUE)</code></pre>
<pre><code>## [1] 56.33333</code></pre>
<p>It worked fine because I named the argument to remove missing values. What if I didn’t state what that argument was?</p>
<pre class="r"><code>mean(y, TRUE)</code></pre>
<pre><code>## Error in mean.default(y, TRUE): &#39;trim&#39; must be numeric of length one</code></pre>
<p>R is expecting a value for trim as the second argument and doesn’t know what to do with the value <code>TRUE</code>. If you name the arguments, then the order is irrelevant.</p>
<pre class="r"><code>mean(na.rm=TRUE, x=y, trim=.1)</code></pre>
<pre><code>## [1] 57.23077</code></pre>
<p>But let’s not get that crazy.</p>
<p>We’ll be getting into heavy function use, specifically with the <code>ggplot</code> function in the next lab.</p>
</div>
</div>
<div id="additional-references" class="section level1">
<h1>Additional References</h1>
<p>There are several other Data Camp courses that all have the first chapter free that you can use to get a start on learning more about how to import and clean up data. Here are a few.</p>
<ul>
<li><a href="https://www.datacamp.com/courses/cleaning-data-in-r">Cleaning Data in R</a></li>
<li><a href="https://www.datacamp.com/courses/importing-data-into-r">Importing Data into R</a></li>
<li>Tidy Data - The <a href="http://vita.had.co.nz/papers/tidy-data.pdf">Journal</a>, and the <a href="https://cran.r-project.org/web/packages/tidyr/vignettes/tidy-data.html">tutorial</a></li>
</ul>
</div>
